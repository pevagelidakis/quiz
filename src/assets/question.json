{   
    "title":"Data Science Quiz",
    "questions":[{
        "questionText":"<p>Which of the following is the correct order of occurrence in a typical SQL statement?</p>",
        "options":[{
                "text":"<p>select, group by, where, having</p>",
                "correct":true
            },{
                "text":"<p>select, where, group by, having</p>"
            },{
                "text":"<p>select, where, having, group by</p>"
            },{
                "text":"<p>select, having, where, group by</p>"
        }],
        "explanation": "<p>Where clause always comes before group by clause and having clause always comes after group by. The select statement always comes first.<br>Question Context: 2 to 12</p><br><img src=\"./images/Q1a.png\"/><br><img src=\"./images/Q1b.png\"/>"
    },{
        "questionText":"<img src =\"../images/Q1a.png\"><img src =\"../images/Q1b.png\"><p>Which of the following is the correct outcome of the SQL query below?<br>Query: SELECT cid FROM ENROLLED WHERE grade = 'C'</p>",
        "options":[{
            "text":"<p>Extract the course ids(cid) where the student received the grade C in the course</p>",
            "correct":"true"
            },{
                "text":"<p>Extract the unique course ids(cid) where the student received the grade C in the course</p>"
            },{
                "text":"<p>Error</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation": "<p>The query will extract the course ids where students receive the grade “C” in the course.</p>"
    },{
        "questionText":"<p>Which of the following is the correct outcome of the SQL query below?<br>Query: SELECT DISTINCT cid FROM ENROLLED WHERE grade = 'C'</p>",
        "options":[{
               "text":"<p>Extract the course ids where the student receive the grade C in the course</p>"
           },{
               "text":"<p>Extract the Distinct course ids where the student receive the grade of C in the course</p>",
               "correct":true
           },{
               "text":"<p>Error</p>"
           },{
               "text":"<p>None of these</p>"
        }],
        "explanation":"<p>By using the DISTINCT keyword, you can extract the distinct course ids where students received a grade of C in the course.</p>"

    },{
        "questionText":"<p>Which of the following is the correct outcome of the SQL query below?<br>Query: SELECT name, cid FROM student, enrolled WHERE student.sid = enrolled.sid AND enrolled.grade = 'C'</p>",
        "options":[{
                "text":"<p>Returns the name of all students and their corresponding course ids</p>"
            },{
                "text":"<p>Returns the name of students and their corresponding course id where they have received grade C</p>",
                "correct":true
            },{
                "text":"<p>Error</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation": "<p>In the above query, we perform an inner join on the ENROLLED and STUDENT tables. Then, it will evaluate the WHERE condition, and then it will return the name of the students and the corresponding course id where they received the grade of C.</p>"
    },{
        "questionText":"<p>Which of the following is the correct outcome of the SQL query below?<br>Query: SELECT student.name, enrolled.grade FROM student, enrolled WHERE student.sid = enrolled.sid AND enrolled.cid = '15-415' AND enrolled.grade IN ('A', 'B')</p>",
        "options":[{
                "text":"<p>Returns the name and grade of the students who took the course '15-415′ and got a grade 'A' or 'B' in that course</p>",
                "correct":true
            },{
                "text":"<p>Returns the name and grade of the students who took the course '15-415′ but didn't get a grade 'A' or 'B' in that course</p>"
            },{
                "text":"<p>Error</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation": "<p>The above query first joined the ENROLLED and STUDENT tables. Then it will evaluate the where condition and then return the name, and grade of the students, who took 15-415 and got a grade of 'A' or 'B' in the course. But for the given two tables, it will give zero records in the output.</p>"
    },{
        "questionText":"<p>Which of the following query will find all the unique students who have taken more than one course?</p>",
        "options":[{
                "text":"<p>SELECT DISTINCT e1.sid FROM enrolled AS e1, enrolled AS e2 WHERE e1.sid != e2.sid AND e1.cid != e2.cid</p>"
            },{
                "text":"<p>SELECT DISTINCT e1.sid FROM enrolled AS e1, enrolled AS e2 WHERE e1.sid = e2.sid AND e1.cid = e2.cid</p>"
            },{
                "text":"<p>SELECT DISTINCT e1.sid FROM enrolled AS e1, enrolled AS e2 WHERE e1.sid != e2.sid AND e1.cid != e2.cid</p>"
            },{
                "text":"<p>SELECT DISTINCT e1.sid FROM enrolled AS e1, enrolled AS e2 WHERE e1.sid = e2.sid AND e1.cid != e2.cid</p>",
                "correct":true
            }],
        "explanation": "<p>Option D would be the right option. This query will first apply self-join on the enrolled table, and then it evaluates the condition e1.sid = e2.sid AND e1.cid != e2.cid.</p>"
    },{
        "questionText":"<p>Which of the following statements will add a column 'F_name' to the STUDENT table?</p>",
        "options":[{
                "text":"<p>ALTER TABLE Student add column ( F_name varchar(20));</p>"
            },{
                "text":"<p>ALTER TABLE Student add F_name varchar(20);</p>",
                "correct":true
            },{
                "text":"<p>ALTER TABLE Student add (F_name varchar(20));</p>"
            },{
                "text":"<p>ALTER TABLE Student add column (F_name);</p>"
        }],
        "explanation": "<p>ALTER TABLE command allows a user to add a new column to a table. Option B is the correct syntax of ALTER to add a column in the table.</p>"
    },{
        "questionText":"<p>Which of the following query(s) will result in a successful insertion of a record in the STUDENT table?<br>Query1: INSERT INTO student (sid, name, login, age, gpa) VALUES (53888, 'Drake', 'drake@cs', 29, 3.5)<br>Query2: INSERT INTO student VALUES (53888, 'Drake', 'drake@cs', 29, 3.5)</p>",
        "options":[{
                "text":"<p>Both queries will insert the record successfully</p>", 
                "correct":true
            },{
                "text":"<p>Query 1 will insert the record successfully, and Query 2 will not</p>"
            },{
                "text":"<p>Query 2 will insert the record successfully, and Query 1 will not</p>"
            },{
                "text":"<p>Both queries will not be able to insert the record successfully</p>"
        }],
        "explanation":"<p> Both queries will successfully insert a row in the student table. Query 1 is useful when you want to provide the target table, columns, and values for new tuples, and Query 2 is a Short-hand version of the insert command</p>"
    },{
        "questionText":"<p>Considering the scenario below, which of the following option(s) will insert a row in the ENROLLED table successfully?<br>'Sid' in the ENROLLED table is 'Foreign Key' referenced by 'Sid' in the STUDENT table. Now you want to insert a record into the ENROLLED table.<br>INSERT INTO ENROLLED values(53667, '15-420', 'C');INSERT INTO ENROLLED values(53666, '15-421', 'C');<br>INSERT INTO ENROLLED values(53667, '15-415', 'C');<br>INSERT INTO ENROLLED values(53666, '15-415', 'C');</p>",
         "options":[{
                "text":"<p>1 and 3</p>"
            },{
                "text":"<p>Only 3</p>"
            },{
                "text":"<p>2 and 4</p>",
                "correct":true
            },{
                "text":"<p>Only 4</p>"
        }],
        "explanation": "<p>Options 2 and 4 will run successfully because in the ENROLLED table's 'Sid' column, you can insert those values which are present in STUDENT's table 'Sid' columns due to the foreign key constraint.</p>"
    },{
        "questionText":"<p>Consider the following queries:<br>Query1: select name from enrolled LEFT OUTER JOIN student on student.sid = enrolled.sid;<br>Query2: select name from student LEFT OUTER JOIN enrolled on student.sid = enrolled.sid;<br>Which of the following option is correct?</p>",
        "options":[{
                "text":"<p>Queries 1 and 2 will give the same results</p>",
                "correct":true
            },{
                "text":"<p>Queries 1 and 2 will give different results</p>"
            },{
                "text":"<p>Query 1 will produce an error, and Query 2 will run successfully</p>"
            },{
                "text":"<p>Query 2 will produce an error, and Query 1 will run successfully</p>"
        }],
        "explanation": "<p>In (LEFT JOIN, RIGHT JOIN, or FULL JOIN) OUTER SQL joins, order matters. But both queries will give the same results because both are dependent on the records present in the table and which column is selected.</p>"
    },{
        "questionText":"<p>Which of the following statements will modify the data type of the “Sid” column in the ENROLLED table?<br>Note: There is no foreign key relationship between tables STUDENT and ENROLLED.</p>",
        "options":[{
                "text":"<p>ALTER TABLE ENROLLED MODIFY (sid varchar(100));</p>",
                "correct":true
            },{
                "text":"<p>ALTER TABLE ENROLLED MODIFY sid varchar(100);</p>"
            },{
                "text":"<p>ALTER TABLE ENROLLED MODIFY column (sid varchar(100));</p>"
            },{
                "text":"<p>ALTER TABLE ENROLLED MODIFY attribute (sid varchar(100));</p>"
        }],
        "explanation": "<p>The “ALTER TABLE MODIFY” is used to modify column definitions in a table. So option A is correct.</p>"
    },{
        "questionText":"<p>Which of the following statement will remove the 'Sid' column from the ENROLLED table?<br>Note: There is no foreign key relationship between tables STUDENT and ENROLLED.</p>",
        "options":[{
                "text":"<p>ALTER TABLE ENROLLED DROP (sid varchar(10) );</p>"
            },{
                "text":"<p>ALTER TABLE ENROLLED DROP COLUMN (sid varchar(10) );</p>"
            },{
                "text":"<p>ALTER TABLE ENROLLED DROP COLUMN Sid;</p>",
                "correct":true
            },{
                "text":"<p>ALTER TABLE ENROLLED MODIFY (sid);</p>"
        }],
        "explanation": "<p>The “ALTER TABLE DROP COLUMN” can be used to drop a column from the table. So Option C is the right answer.</p>"
    },{

        "questionText":"<p>Which of the following command(s) is/are related to transaction control in SQL?</p>",
        "options":[{
                "text":"<p>ROLLBACK</p>"
            },{
                "text":"<p>COMMIT</p>"
            },{
                "text":"<p>SAVEPOINT</p>"
            },{
            "text":"<p>All of the above</p>",
            "correct":true
        }],
        "explanation": "<p>All are related to transaction control in SQL.</p>"
    },{

    },{
        "questionText":"<p>Which of the following is true for a primary key?</p>",
        "options":[{
                "text":"<p>It can take a value more than once</p>"
            },{
                "text":"<p>It can take null values</p>"
            },{
                "text":"<p>It can't take null values</p>",
                "correct":true
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation": "<p>In a relational schema, there exists only one primary key, and it can't take null values. So option C is the correct answer.</p>"
    },{
        "questionText":"<p>What is the difference between a primary key and a unique key?</p>",
        "options":[{
                "text":"<p>Primary key cannot be a date variable, whereas a unique key can be</p>"
            },{
                "text":"<p>You can have only one primary key, whereas you can have multiple unique keys</p>",
                "correct":true
            },{
                "text":"<p>Primary key can take null values, but the unique key cannot be null values</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation": "<p>You can create a date variable as a primary key in a table. In a relational schema, you can have only one primary key and there may be multiple unique keys present in the table. A unique key can take null values.</p>"
    },{
        "questionText":"<p>Which of the following statement(s) is/are true for UPDATE in SQL?<br>You can update only a single table using the UPDATE command<br>You can update multiple tables using the UPDATE command<br>In the UPDATE command, you must list what columns to update with their new values (separated by commas).<br>To update multiple targeted records, you need to specify the UPDATE command using the WHERE clause.<br>Select the correct option:</p>",
        "options":[{
                "text":"<p>1, 3 and 4</p>",
                "correct": true
            },{
                "text":"<p>2, 3 and 4</p>"    
            },{
                "text":"<p>3 and 4</p>"
            },{
                "text":"<p>1 only</p>"
        }],
        "explanation": "<p>Options are self-explanatory.</p>"
    },{
        "questionText":"<p>Which of the following is true for TRUNCATE in SQL?</p>",
        "options":[{
                "text":"<p>It is usually slower than the DELETE command</p>"
            },{
                "text":"<p>It is usually faster than the DELETE command</p>",
                "correct":true
            },{
                "text":"<p>There is no comparison between DELETE & TRUNCATE</p>"
            },{
                "text":"<p>Truncate command can be rolled back</p>"
        }],
        "explanation": "<p>TRUNCATE is faster than delete bcoz truncate is a DDL command. So it does not produce any rollback information, and the storage space is released while the delete command is a DML command. Also, it produces rollback information, and space is not deallocated using the delete command.</p>"
    },{
        "questionText":"</p>Which of the following statement is correct about the 'CREATE TABLE' command while creating a table?</p>",
        "options":[{
                "text":"<p>We need to assign a datatype to each column</p>",
                "correct":true
            },{
                "text":"<p>We have flexibility in SQL. We can assign a data type to a column even after creating a table</p>"
            },{
                "text":"<p>It is mandatory to insert at least a single row while creating a table</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation": "<p>Each column must possess behavioral attributes like data types and precision to build the structure of the table.</p>"
    },{
        "questionText":"<p>Which of the following are the synonyms for the 'column' and 'row' of a table?<br>Row = [Tuple, Record]<br>Column = [Field, Attribute]<br>Row = [Tuple, Attribute]<br>Columns = [Field, Record]<br>Select the correct option:</p>",
        "options":[{
                "text":"<p>1 and 2</p>",
                "correct":true
            },{
                "text":"<p>3 and 4</p>"
            },{
                "text":"<p>Only 1</p>"
            },{
                "text":"<p>Only 2</p>"
        }],
        "explanation": "<p>In DBMS records are also known as tuples and rows. And columns are known as attributes and fields.</p>"
    },{
        "questionText":"<p>Which of the following operator is used for comparing 'NULL' values in SQL?</p>",
        "options":[{
                "text":"<p>Equal</p>"
            },{
                "text":"<p>IS</p>",
                "correct":true
            },{
                "text":"<p>IN</p>"
            },{
                "text":"<p>None of Above</p>"
        }],
        "explanation": "<p>In SQL, if you want to compare a null value you need to use IS statement.</p>"
    },{
        "questionText":"<p>Which of the following statement(s) is/are true about the “HAVING” and “WHERE” clause in SQL?<br>\n“WHERE” is always used before “GROUP BY” and HAVING after “GROUP BY”<br>\n“WHERE” is always used after “GROUP BY” and “HAVING” before “GROUP B<br>“WHERE” is used to filter rows but “HAVING” is used to filter groups<br>\n“WHERE” is used to filter groups but “HAVING” is used to filter rows<br>Select the correct option:</p>",
        "options":[{
                "text":"<p>1 and 3</p>",
                "correct":true
            },{
                "text":"<p>1 and 4</p>"
            },{
                "text":"<p>2 and 3</p>"
            },{
                "text":"<p>2 and 4</p>"
        }],
        "explanation": "<p>HAVING is performed after GROUP BY. If you have to apply some conditions to get results. you need to use WHERE before group by. Aggregate functions are used with the group by.</p>"
    },{
        "questionText":"Identify which of the following column “A” or “C” given in the below table is a “Primary Key” or “Foreign Key”.</p><img src=\"./images/Q22.png\"/><br>\n<p>Note: We have defined 'Foreign Key' and 'Primary Key' in a single table</p>",
        "options":[{
                "text":"<p>Column 'A' is Foreign Key, and Column 'C' is Primary Key'</p>"
            },{
                "text":"<p>Column 'C' is Foreign Key, and Column 'A' is 'Primary Key'</p>",
                "correct":true
            },{
                "text":"<p>Both can be 'Primary Key'</p>"
            },{
                "text":"<p>Based on the above table, we cannot tell which column is 'Primary Key' and which is 'Foreign Key'</p>"
        }],
        "explanation": "<p>Column A is taking unique values, and column A doesn't have null values. So it can be considered the Primary key of this table. Whereas B is the example of a foreign key because all values present in this column are already present in column A.</p>"
    },{
        "questionText":"<p>What are the tuples additionally deleted to preserve reference integrity when the rows (2,4) are deleted from the below table?<br>\nSuppose you are using 'ON DELETE CASCADE'.<br></p>\n<img src=\"./images/Q23.png\"/><br>\n<p>Note: We have defined 'Foreign Key' and 'Primary Key' in a single table</p>",
        "options":[{
                "text":"<p>(5,2), (7,2), (9,5)</p>",
                "correct":true
            },{
                "text":"<p>(5,2), (7,2)</p>"
            },{
                "text":"<p>(5,2), (7,2), (9,5), (3,4)</p>"
            },{
                "text":"<p>(5,2), (7,2), (9,5),(6,4)</p>"
        }],
        "explanation": "<p>When (2,4) is deleted. Since C is a foreign key referring to A with delete on cascade, all entries with value 2 in C must be deleted. So (5, 2) and (7, 2) are deleted. As a result of this, 5 and 7 are deleted from A, which causes (9, 5) to be deleted.</p>"
    },{
        "questionText":"<p>What will be the output for the following queries given the below scenario?You are given a table/relation, “EMPLOYEE,” which has two columns ('Name' and 'Salary'). The Salary column in this table has some NULL values. Now, I want to find out the records which have null values.</p><img src=\"./images/Q24.png\" /><br><p> 1. SELECT * FROM EMPLOYEE WHERE Salary <> NULL;<br>Query 2. SELECT * FROM EMPLOYEE WHERE Salary = NULL;</p>",
        "options":[{
                "text":"<p>Query 1 will give the last 4 rows as output (excluding null value)</p>"
            },{
                "text":"<p>Query 2 will give the first row as output (only record containing null value)</p>"
            },{
                "text":"<p>Query 1 and Query 2 both will give the same result</p>",
                "correct":true
            },{
                "text":"<p>Can't say</p>"
        }],
        "explanation": "<p>If we compare(<>, =) Salary, it will give 0 records. Below are the following reasons:<br>Salary = Null is unknown<br>Salary <> Null is unknown</p>"
    },{
        "questionText":"<p>What is the difference between TRUNCATE, DELETE, and DROP? Which of the following statement(s) is/ are correct?<br>DELETE operations can be rolled back, but TRUNCATE and DROP operations cannot be rolled back.<br>DELETE operations cannot be rolled back, but TRUNCATE and DROP operations can be rolled back.<br>DELETE is an example of DML (Data Manipulation Language), but the remaining are examples of DDL (Data Definition Language).<br>All are an example of DDL<br>Select the correct option:</p>",
        "options":[{
                "text":"<p>1 and 3</p>",
                "correct":true
            },{
                "text":"<p>2 and 3</p>"
            },{
                "text":"<p>1 and 4</p>"
            },{
                "text":"<p>2 and 4</p>"
        }],
        "explanation": "<p>Options are self-explanatory.</p>"
    },{
        "questionText":"<p>Which of the following statements is correct for the output of each query given below?<br>Tables A and B have three columns (namely: 'id', 'age', and 'name'). These tables have no 'null' values, and there are 100 records in each table.<br>Here are two queries based on these two tables, 'A' and 'B':<br>Query1: SELECT A.id FROM A WHERE A.age > ALL (SELECT B.age FROM B WHERE B.name = 'Ankit')<br>Query2: SELECT A.id FROM A WHERE A.age > ANY (SELECT B.age FROM B WHERE B.name = 'Ankit')</p>",
        "options":[{
                "text":"<p>The number of tuples in the output of Query 1 will be more than or equal to the output of Query 2</p>"
            },{
                "text":"<p>The number of tuples in the output of Query 1 will be equal to the output of Query 2</p>"
            },{
                "text":"<p>The number of tuples in the output of Query 1 will be less than or equal to the output of Query 2</p>",
                "correct":true
            },{
                "text":"<p>Can't say</p>"
        }],
        "explanation": "<p>ANY and ALL operate on subqueries that return multiple values. ANY returns true if any of the subquery values meet the condition. But in the case of ALL, it will return the records if all conditions are true. So option C is correct.</p>"
    },{
        "questionText":"<p>What is true about the relation (table) in different normal forms (1NF, 2NF, 3NF)?<br>1. If a relation satisfies the conditions of 1NF. It will automatically satisfy the conditions of 2NF<br>2. If a relation satisfies the conditions of 2NF. It will automatically satisfy the conditions of 1NF<br>3. If a relation satisfies the conditions of 3NF. It will automatically satisfy the conditions of 1NF<br>4. If a relation satisfies the conditions of 2NF. It will automatically satisfy the conditions of 3NF<br>Select the correct option:</p>",
        "options":[{
                "text":"<p>1 and 2</p>"
            },{
                "text":"<p>2 and 3</p>",
                "correct":true
            },{
                "text":"<p>1 and 3</p>"
            },{
                "text":"<p>2 and 4</p>"
        }],
        "explanation": "<p>If a relation satisfies higher normal forms, it automatically satisfies lower normal forms also. For example, if a relation is satisfying kNF it will automatically satisfy gNF where g<=k.</p>"
    },{
        "questionText":"<p>Suppose you want to compare three keys ('Primary Key', 'Super Key', and 'Candidate Key') in a database. Which of the following option(s) is/are correct?Minimal super key is a candidate key<br>Only one Candidate Key can be Primary Key<br>All super keys can be a candidate key<br>We cannot find the “Primary Key” from “Candidate Key”<br>Select the correct option:</p>",
        "options":[{
                "text":"<p>1 and 2</p>",
                "correct":true
            },{
                "text":"<p>2 and 3</p>"
            },{
                "text":"<p>1 and 3</p>"
            },{
                "text":"<p>2 and 4</p>"
        }],
        "explanation": "<p>Options are self-explanatory</p>"
    },{
        "questionText":"<p>Consider a relation R with the schema R (A, B, C, D, E, F) with a set of functional dependencies F as follows:<br>{AB->C, BC->AD, D->E, CF->B}<br>Which of the following will be the output of DA+?<br>Note: For any X, X+ is the closure of X.</p>",
        "options":[{
                "text":"<p>DA</p>"
            },{
                "text":"<p>DAE</p>",
                "correct":true
            },{
                "text":"<p>ABCD</p>"
            },{
                "text":"<p>ABCDEF</p>"
        }],
        "explanation": "<p>(DA)+ = DAE</p>"
    },{
        "questionText":"<p>What is the output of the following SQL query?<br>Suppose you have a table “Loan_Records”.</p><br><img src =\"../images/Q30.png\"><br><p>SELECT Count(*)  FROM  ( (SELECT Borrower, Bank_Manager FROM   Loan_Records) AS S NATURAL JOIN (SELECT Bank_Manager, Loan_Amount FROM   Loan_Records) AS T );</p>",
        "options":[{
                "text":"<p>4</p>"
            },{
                "text":"<p>5</p>",
                "correct":true
            },{
                "text":"<p>8</p>"
            },{
                "text":"<p>10</p>"
        }],
        "explanation":"<p>Temporary table S is given below:</p><br><img src =\"../images/Q30e1.png\"><p>Temporary table T is given below</p><br><img src =\"../images/Q30e2.png\"><p>If you apply natural join on both tables (S and T) and evaluate the condition on 'Bank_Manager'. You will get the following intermediate table after applying natural join</p><br><img src =\"../images/Q30e3.png\"><p>“Sunderjan” appears two times in the Bank_Manager column, so there will be four entries with Bank_Manager as “Sunderjan”. So count(*) will give the 5 output in the outer query.</p>"
    },{
        "questionText":"<p>Is the “SELECT” operation in SQL equivalent to the “PROJECT” operation in relational algebra?</p>",
        "options":[{
                "text":"<p>Yes, both are equivalent in all the cases</p>"
            },{
                "text":"<p>No, both are not equivalent</p>",
                "correct":true
            },{
                "text":"<p>It depends</p>"
            },{
                "text":"<p>Can't say</p>"
        }],
        "explanation":"<p>In relational algebra 'PROJECT' operation gives the unique record, but in the case of the 'SELECT' operation in SQL, you need to use a distinct keyword for get unique records.</p>"
    },{
        "questionText":"<p><b>Table: AV1</b></p><br><img src=\"../images/Q32-36.png\"><br><p>What will be the output of the following query?<br>Query 1: Select name from AV1 where name like '%a%'</p>",
        "options":[{
                "text":"<p>Saurav, Ankit, Kunal, Deepak, Swati, Faizan</p>",
                "correct":true
            },{
                "text":"<p>Saurav, Kunal, Deepak, Swati, Faizan</p>"
            },{
                "text":"<p>Kunal, Deepak, Swati, Faizan</p>"
            },{
                "text":"<p>None of above</p>"
        }],
        "explanation":"<p>'%a%' is the SQL way to use regular expression for matching words that contain the letter a. According to the projection, we would like to take all of them</p>"
    },{
        "questionText":"<p><b>Table: AV1</b></p><br><img src=\"../images/Q32-36.png\"><br><p>What will be the output for the below query?<br>Query: SELECT Name from AV1 where Name LIKE '%______%';<br>Note: The above operation contains 6 underscores ('_') used with the LIKE operator.</p>",
        "options":[{
                "text":"<p>It will return names where the number of characters in names is greater than or equal to 6</p>",
                "correct":true
            },{
                "text":"<p>It will return names where the number of characters in names is greater than 6</p>"
            },{
                "text":"<p>It will return names where the number of characters in names is less than or equal to 6</p>"
            },{
                "text":"<p>It will give an error</p>"
        }],
        "explanation":"<p>The query will search for records in column 'Name' where the number of characters in names is greater than or equal to 6.</p>"
    },{
        "questionText":"<p><b>Table: AV1</b></p><br><img src=\"../images/Q32-36.png\"><br><p>What will be the output of the below query?<br>Query: SELECT Company, AVG(Salary) FROM AV1 HAVING AVG(Salary) > 1200 GROUP BY Company WHERE Salary > 1000 ;</p>",
        "options":[{
                "text":"<img src=\"../images/A34.png\"/>"
            },{
                "text":"<img src=\"../images/B34.png\"/>"
            },{
                "text":"<img src=\"../images/C34.png\"/>"
            },{
                "text":"<p>None of these</p>",
                "correct":true
        }],
        "explanation":"<p>This query will give the error because 'WHERE' is always evaluated before 'GROUP BY' and 'Having' is always evaluated after 'GROUP BY'.</p>"
    },{
        "questionText":"<p><b>Table: AV1</b></p><br><img src=\"../images/Q32-36.png\"><br><p>What will be the output for the below Query 1 and Query 2?<br>Query 1: SELECT MAX(Salary) FROM AV1 WHERE Salary < (SELECT MAX(Salary) from AV1);<br>Query 2: WITH S AS (SELECT Salary, ROW_NUMBER() OVER(ORDER BY Salary DESC) AS RowNum FROM AV1) SELECT Salary FROM S WHERE RowNum = 2;</p>",
        "options":[{
                "text":"<p>Query 1 output = 1200 and Query 2 output =1200</p>",
                "correct":true
            },{
                "text":"<p>Query 1 output = 1200 and Query 2 output =1400</p>"
            },{
                "text":"<p>Query 1 output = 1400 and Query 2 output =1200</p>"
            },{
                "text":"<p>Query 1 output = 1400 and Query 2 output =1400</p>"
        }],
        "explanation":"<p>Both queries will generate the second-highest salary in AV1, which is 1200. Hence A is the right option.</p>"
    },{
        "questionText":"<p><b>Table: AV1</b></p><br><img src=\"../images/Q32-36.png\"><br><p>Consider the following relational schema.<br>Students(rollno: integer, sname: string)<br>Courses (courseno: integer, cname: string)<br>Registration (rollno: integer, courseno: integer, percent: real)<br>Now, which of the following query would be able to find the unique names of all students having scores of more than 90% in the course no 107?</p>",
        "options":[{
                "text":"<p>SELECT DISTINCT S.sname FROM Students as S, Registration as R WHERE R.rollno=S.rollno AND R.courseno=107 AND R.percent >90</p>",
                "correct":true
            },{
                "text":"<p>SELECT UNIQUE S.sname FROM Students as S, Registration as R WHERE R.rollno=S.rollno AND R.courseno=107 AND R.percent >90</p>"
            },{
                "text":"<p>SELECT sname FROM Students as S, Registration as R WHERE R.rollno=S.rollno AND R.courseno=107 AND R.percent >90</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation":"<p>Option A is true, Option B will give the error (“UNIQUE” is not used in SQL), and in option C, unique names will not be the output.</p>"
    },{
        "questionText":"<p>Which of the following options is when related to the following queries?<br>Consider the relation T1 (A, B) in which (A, B) is the primary key and the relation T2 (A, C) where A is the primary key. Assume there are no null values and no foreign keys or integrity constraints.<br>Query 1: select A from T1 where A in (select A from T2)<br>Query 2: select A from T2 where A in (select A from T1)</p>",
        "options":[{
                "text":"<p>Both queries will definitely give the same result</p>"
            },{
                "text":"<p>Both queries may give the same result</p>",
                "correct":true
            },{
                "text":"<p>Both queries will definitely give a different result</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation":"<p>For the same values (values should be unique) for column A in tables T1 and T2. Query 1 and Query 2 will give the same output. Hence B is true</p>"
    },{
        "questionText":"<p>Which of the following options is correct for the following queries?<br>Query 1. SELECT emp.id, department.id FROM emp NATURAL JOIN department<br>Query 2. SELECT emp.id, department.id FROM department NATURAL JOIN emp</p>",
        "options":[{
                "text":"<p>Both queries will give the same outputs</p>",
                "correct":true
            },{
                "text":"<p>Both queries will give different output</p>"
            },{
                "text":"<p>Need table structure</p>"
            },{
                "text":"<p>None of these</p>"
        }],
        "explanation":"<p>For Natural joins, the order doesn't matter. The queries will return the same results.</p>"
    },{
        "questionText":"<p>Which of the following sequences CANNOT be the sequence for the numbers examined for the below scenario?<br>Indexing is useful in a database for fast searching. Generally, B-tree is used for both clustered index and non-clustered index in a database. Now, you want to use Binary Search Tree instead of B-tree.<br>Suppose there are numbers between 1 and 100, and you want to search for the number 35 using the Binary Search Tree algorithm.</p>",
        "options":[{
                "text":"<p>10, 75, 64, 43, 60, 57, 55</p>"
            },{
                "text":"<p>90, 12, 68, 34, 62, 45, 55</p>"
            },{
                "text":"<p>9, 85, 47, 68, 43, 57, 55</p>",
                "correct":true
            },{
                "text":"<p>79, 14, 72, 56, 16, 53, 55</p>"
        }],
        "explanation":"<p>In BST, on the right side of the parent number should be greater than it, but in C after 47, 43 appears that is wrong.</p>"
    },{
        "questionText":"<p>Which query will take less time to execute in the below scenario?<br> Suppose you have a CSV file that has 3 columns ('User_ID', 'Gender', 'Product_ID') and 7,150,884 rows. You have created a table “train” from this file in SQL.<br> Now, you run Query 1 as given below and get the following output:<br> Query 1: EXPLAIN select * from train where Product_ID = 'P00370853';<br> OUTPUT:<br> QUERY PLAN<br> --------------------------------------------------------------<br> Seq Scan on train (cost=0.00..79723.88 rows=16428 width=68)<br> Filter: ((product_id)::text = 'P00370853'::text)<br> (2 rows)<br> You have now created Product_ID column as an index in train table using the below SQL query:<br> CREATE INDEX product_ID ON train(Product_ID)<br> And you run Query 2 (same as Query 1) on “train” and get the following output.<br> Query 2: EXPLAIN select * from train where Product_ID = 'P00370853';<br> OUTPUT:<br> QUERY PLAN<br> -------------------------------------------------------------------------------<br> Bitmap Heap Scan on train (cost=829.53..40738.85 rows=35754 width=68)<br> Recheck Cond: ((product_id)::text = 'P00370853'::text) -> Bitmap Index Scan on product_id (cost=0.00..820.59 rows=35754 width=0)<br> Index Cond: ((product_id)::text = 'P00370853'::text)<br> (4 rows)</p>",
        "options":[{
                "text":"<p>Query 1</p>"
            },{
                "text":"<p>Query 2</p>",
                "correct":true
            },{
                "text":"<p>Both queries will take the same time</p>"
            },{
                "text":"<p>Can't say</p>"
        }],
        "explanation":"<p>For Query Plan for Query 1, the execution time is 79723.88, and for Query Plan for Query 2, the execution time is 40738.85. So Query 2 is taking less time.</p>"
    },{
        "questionText":"<p>Which query will take less time to execute?<br> Suppose you have a CSV file that has 3 columns ('User_ID', 'Gender', 'product_ID') and 7150884 rows. You have created a table “train” from this file in SQL.<br> Now, you run Query 1 (mentioned below):<br> Query1: EXPLAIN SELECT * from train WHERE product_ID like '%7085%';<br> Then, you created product_ID columns as an index in 'train' table using below SQL query:<br> CREATE INDEX product_ID ON train(Product_ID)<br> Suppose you run Query 2 (same as Query 1) on train table.<br> Query 2: EXPLAIN SELECT * from train WHERE product_ID like '%7085%';<br> Let T1 and T2 be the time taken by Query 1 and Query 2, respectively.</p>",
        "options":[{
                "text":"<p>T1>T2</p>"
            },{
                "text":"<p>T2>T1</p>"
            },{
                "text":"<p>T1~T2</p>",
                "correct":true
            },{
                "text":"<p>Can't say</p>"
        }],
        "explanation":"<p>The addition of the index didn't change the query execution plan since the index doesn't help for the 'LIKE' query.</p>"
    },{
        "questionText":"<p>Which of the following is true for the query time?<br>Suppose you have a table 'Employee'. In the Employee table, you have a column named Salary. Now, you applied Query 1 on the Employee table.<br>Query 1: SELECT * FROM Employee where Salary*100 > 5000;<br>After that, you create an index on Salary columns, and then you re-run Query 2 (same as Query 1).<br>Query 2:  SELECT * FROM Employee where Salary*100 > 5000;<br>Here, Query 1 is taking T1 time, and Query 2 is taking T2 time.</p>",
        "options":[{
                "text":"<p>T1 > T2</p>"
            },{
                "text":"<p>T2 > T1</p>"
            },{
                "text":"<p>T1 ~ T2</p>",
                "correct":true
            },{
                "text":"<p>Can't say</p>"
        }],
        "explanation":"<p>The addition of the index didn't change the query execution plan. The index on the rating will not work for the query (Salary * 100 > 5000). Theoretically, it might work in this case, but obviously, the system is not “smart” enough to work that way; But you can create an index on (Salary * 100) which will help.</p>"
    },{
        "questionText":"<p>Which of the following is true for the query time?<br>Suppose you have a table 'Employee'. In the Employee table, you have a column named Salary. Now, you applied Query 1 on the Employee table.<br>Query 1: SELECT * FROM Employee where Salary*100 > 5000;<br>After that, you create an index on Salary columns, and then you re-run Query 2 (same as Query 1).<br>Query 2:  SELECT * FROM Employee where Salary*100 > 5000;<br>Here, Query 1 is taking T1 time, and Query 2 is taking T2 time.</p>",
        "options":[{
                "text":"<img src=\"../images/44A.png\"/>",
                "correct":true
            },{
                "text":"<p>Error</p></p>"
            },{
                "text":"<img src=\"../images/44C.png\"/>"
            },{
                "text":"<p>None of these</p></p>"
        }],
        "explanation":""
    },{
        "questionText":"<p>Which of the following is true for the query time?<br>Suppose you have a table 'Employee'. In the Employee table, you have a column named Salary. Now, you applied Query 1 on the Employee table.<br>Query 1: SELECT * FROM Employee where Salary*100 > 5000;<br>After that, you create an index on Salary columns, and then you re-run Query 2 (same as Query 1).<br>Query 2:  SELECT * FROM Employee where Salary*100 > 5000;<br>Here, Query 1 is taking T1 time, and Query 2 is taking T2 time.</p>",
        "options":[{
                "text":"<p>1 and 3</p>"
            },{
                "text":"<p>2 and 4</p>"
            },{
                "text":"<p>1, 3 and 4</p>"
            },{
                "text":"<p>All of these</p>",
                "correct":true
        }],
        "explanation":""
    },{
        "questionText":"<p>Which of the following will be the output of Query 5 below?<br>Suppose I created a table called 'avian' using below SQL query:<br><br>Query : CREATE TABLE avian ( emp_id SERIAL PRIMARY KEY, name varchar);<br>Now, I want to insert some records in the table avian:<br>Query1: INSERT INTO avian (name) VALUES('FRAZY');<br>Query2: INSERT INTO avian (name) VALUES('ANKIT');<br>Query3: INSERT INTO avian (name) VALUES('SUNIL');<br>Query4: INSERT INTO avian (name) VALUES('SAURAV');<br>Query5: Select * FROM avian;</p>",
        "options":[{
                "text":"<img src=\"./images/46A.png\">",
                "correct":true
            },{
                "text":"<img src=\"./images/46B.png\">"
            },{
                "text":"<p>Error</p>"
            },{
                "text":"<p>None of these</p>"
            }],
            "explanation": "<p>At the time of table creation Avian, we have used SERIAL for 'emp_id', which autoincrement emp_id whenever you insert a record in table avian. Hence A is true.</p>"
    }]
}